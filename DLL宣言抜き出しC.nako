REM = 「 DLL宣言の取得
cnako.exe "%0"
exit
REM 」
#----------------------------------------------------------
# dnako.dpr からDLL宣言を取得する
#----------------------------------------------------------
インポート変数定義＝「」
インポート代入処理＝「」

#----------------------------------------------------------
# APIソースの切り取り
#----------------------------------------------------------
S=「{母艦パス}dnako.dpr」を開く。
SRC=Sの「///<DNAKOAPI:BEGIN>」から「///<DNAKOAPI:END>」まで範囲切り取る。
SRCを反復
　対象の１から4文字抜き出す。
　もし((それ=「func」)||(それ=「proc」))ならば
　　　対象をAPI取得処理
　違えば
　　　続ける。

雛型の「@@VAR@@」をインポート変数定義に置換。
「{母艦パス}dnako_import_def.h」へ保存。

雛型2の「@@LET@@」をインポート代入処理に置換。
「{母艦パス}dnako_import_let.h」へ保存。
おわり。

●API取得処理（Sを）
　　タイプ＝Sの「 」まで切り取る
　　メソッド定義＝Sの「//」まで切り取る
　　解説＝トリム（S）
　　＃引数付きかどうか？
　　メソッド名＝「;xxx;」
　　引数定義=「」
　　リターンタイプ＝「void」
　　もし、(メソッド定義で「(」が何文字目) > 0 ならば
　　　　メソッド名＝メソッド定義の「(」まで切り取る
　　　　引数定義＝メソッド定義の「)」まで切り取る
　　　　メソッド定義の「:」まで切り取る。
　　違えば
　　　　SS＝メソッド定義の「;」まで切り取る。
　　　　メソッド名＝SSの「:」まで切り取る
　　　　メソッド定義＝SS
　　もし、タイプ＝「function」ならば
　　　　リターンタイプ＝メソッド定義の「;」まで切り取る。
　　　　リターンタイプ＝タイプチェック（リターンタイプ）
　　引数定義=トリム(引数定義)
　　もし、引数定義＝「」ならば
　　　　引数定義＝「void」
　　違えば
　　　　Ｒ＝「」
　　　　引数定義を「;」で区切る
　　　　反復
　　　　　　「:」で区切る
　　　　　　T=それ\1
　　　　　　N=それ\0
　　　　　　N=トリム(N)
　　　　　　Nで"var "が何文字目
　　　　　　もし、それ＝１ならば
　　　　　　　　T=T&"*"
　　　　　　　　N=Nの「var」を「」に単置換
　　　　　　Ｔ＝タイプチェック（Ｔ）
　　　　　　Nを「,」で区切る
　　　　　　反復
　　　　　　　　Ｒに「{Ｔ}」を配列追加
　　　　引数定義＝Ｒを「,」で配列結合
　　インポート変数定義＝インポート変数定義＆「//●{解説}
DNAKO_DEF {リターンタイプ}(__stdcall *{メソッド名})({引数定義});
」
　　インポート代入処理＝インポート代入処理＆「」＆
「	{メソッド名} = ({リターンタイプ}(__stdcall*)({引数定義})) ::GetProcAddress( hDll,"{メソッド名}");
」

●タイプチェック（Ｓ）
　　Ｓの「PChar」を「char*」に置換。
　　「Integer」を「int」に置換。
　　「Pint」を「int*」に置換。
　　トリム

#-----------------------------------------------------------------------
!雛型は『
///
/// dnako.dll の API を定義したもの
/// generated by DLL宣言抜き出しC.nako
///

/// APIの定義
@@VAR@@

』
!雛型2は『
///
/// dnako.dll の API を代入するもの
/// generated by DLL宣言抜き出しC.nako
///

@@LET@@
』
